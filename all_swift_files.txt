=== TighterMenubar/MenuBarPreviewView.swift ===

import SwiftUI
import AppKit
import os.log

struct ContentView: View {
    // MARK: - State Properties
    
    /// Controls the space *between* each menu bar item.
    @State private var menuItemSpacing: CGFloat = 8.0
    
    /// Controls the padding around each menu bar item when selected/hovered.
    @State private var menuItemPadding: CGFloat = 8.0

    /// Tracks the name of the symbol currently being hovered over.
    @State private var hoveredSymbol: String? = nil
    
    /// Provides feedback to the user after an action is performed.
    @State private var feedbackMessage: String = ""
    
    // Use the SystemFontManager to get a dynamically updating font size.
    @StateObject private var fontManager = SystemFontManager()
    
    // MARK: - Logging
    private let logger = Logger(subsystem: "com.tightermenubar.app", category: "ContentView")

    // MARK: - Properties

    /// A collection of SF Symbol names to populate the simulated menu bar.
    private let symbolNames = [
        "wifi", "battery.100.bolt", "speaker.wave.2.fill",
        "magnifyingglass", "command.circle", "music.note"
    ]

    // MARK: - Body

    var body: some View {
        VStack(spacing: 20) {
            // MARK: - Simulated Menu Bar
            VStack(alignment: .leading, spacing: 8) {
                Text("Live Preview")
                    .font(.headline)
                    .foregroundStyle(.secondary)
                
                // The HStack simulates the menu bar, with its spacing bound to our state variable.
                HStack(spacing: menuItemSpacing) {
                    ForEach(symbolNames, id: \.self) { symbolName in
                        Image(systemName: symbolName)
                            // Use the dynamically updating font size from our manager.
                            .font(.system(size: fontManager.menuBarFontSize))
                            .padding(menuItemPadding / 4) // Scale padding to match preview
                            .background(hoveredSymbol == symbolName ? Color.gray.opacity(0.3) : Color.clear)
                            .cornerRadius(4)
                            .onHover { isHovering in
                                withAnimation(.easeIn(duration: 0.1)) {
                                    hoveredSymbol = isHovering ? symbolName : nil
                                }
                                logger.debug("Symbol hover state changed: \(symbolName) - hovering: \(isHovering)")
                            }
                    }
                }
                .padding(.horizontal, 12)
                .frame(height: 24)
                .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 6))
            }
            
            // MARK: - Interactive Controls
            VStack(alignment: .leading, spacing: 16) {
                Text("Controls")
                    .font(.headline)
                    .foregroundStyle(.secondary)
                
                VStack(alignment: .leading, spacing: 12) {
                    // Item Spacing Control
                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Item Spacing")
                                .font(.subheadline)
                            Spacer()
                            Text("\(Int(menuItemSpacing))")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                                .monospacedDigit()
                        }
                        Slider(
                            value: $menuItemSpacing,
                            in: 1...10,
                            step: 1.0
                        )
                        .onChange(of: menuItemSpacing) { oldValue, newValue in
                            logger.debug("Menu item spacing changed from \(oldValue) to \(newValue)")
                        }
                    }
                    
                    // Item Padding Control
                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Item Padding")
                                .font(.subheadline)
                            Spacer()
                            Text("\(Int(menuItemPadding))")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                                .monospacedDigit()
                        }
                        Slider(
                            value: $menuItemPadding,
                            in: 1...10,
                            step: 1.0
                        )
                        .onChange(of: menuItemPadding) { oldValue, newValue in
                            logger.debug("Menu item padding changed from \(oldValue) to \(newValue)")
                        }
                    }
                }
                
                // Action Buttons
                VStack(spacing: 8) {
                    HStack(spacing: 8) {
                        Button("Apply Changes") {
                            logger.info("Apply Changes button pressed")
                            applySettings()
                        }
                        .buttonStyle(.borderedProminent)
                        .controlSize(.regular)
                        
                        Button("Reset to Default") {
                            logger.info("Reset to Default button pressed")
                            resetSettings()
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.regular)
                    }
                    
                    // Feedback Message - right below Apply Changes button
                    if !feedbackMessage.isEmpty {
                        Text(feedbackMessage)
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    
                    // Logout button with explanation
                    VStack(spacing: 4) {
                        Text("Changes require logout to take effect")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .multilineTextAlignment(.center)
                        
                        Button("Log Out Now") {
                            logger.info("Log Out button pressed")
                            logOutUser()
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.small)
                        .foregroundStyle(.orange)
                    }
                    .padding(.top, 4)
                }
            }
        }
        .padding(20)
        .frame(width: 320, height: 320)
        .background(.regularMaterial)
        .onAppear {
            logger.info("ContentView appeared - initializing with spacing: \(menuItemSpacing), padding: \(menuItemPadding)")
        }
    }
    
    // MARK: - System Command Functions
    
    /// Applies the current spacing value to the system using the `defaults` command.
    private func applySettings() {
        let spacingValue = Int(menuItemSpacing)
        let paddingValue = Int(menuItemPadding)
        
        logger.info("Applying settings - spacing: \(spacingValue), padding: \(paddingValue)")
        
        // Apply both spacing and padding settings independently
        let spacingSuccess = runCommand(
            path: "/usr/bin/defaults",
            arguments: ["write", "-g", "NSStatusItemSpacing", "-int", "\(spacingValue)"],
            description: "Setting NSStatusItemSpacing to \(spacingValue)"
        )
        
        let paddingSuccess = runCommand(
            path: "/usr/bin/defaults",
            arguments: ["write", "-g", "NSStatusItemSelectionPadding", "-int", "\(paddingValue)"],
            description: "Setting NSStatusItemSelectionPadding to \(paddingValue)"
        )
        
        if spacingSuccess && paddingSuccess {
            logger.info("Successfully applied defaults settings, attempting to restart ControlCenter")
            
            // Relaunch Control Center to make the changes take effect.
            let killSuccess = runCommand(
                path: "/usr/bin/killall", 
                arguments: ["ControlCenter"],
                description: "Restarting ControlCenter to apply changes"
            )
            
            if killSuccess {
                showFeedback("Settings Applied! Log out and back in to see changes.")
                logger.info("Settings applied successfully and ControlCenter restarted")
            } else {
                showFeedback("Settings saved, but ControlCenter restart failed. You may need to restart manually or log out/in.")
                logger.warning("Settings applied but ControlCenter restart failed - user may need manual restart")
            }
        } else {
            showFeedback("Failed to apply some settings. Check Console.app for details.")
            logger.error("Failed to apply one or more settings")
        }
    }
    
    /// Resets the menu bar spacing to the macOS default.
    private func resetSettings() {
        logger.info("Resetting settings to default")
        
        let spacingSuccess = runCommand(
            path: "/usr/bin/defaults",
            arguments: ["delete", "-g", "NSStatusItemSpacing"],
            description: "Removing NSStatusItemSpacing setting"
        )
        
        let paddingSuccess = runCommand(
            path: "/usr/bin/defaults",
            arguments: ["delete", "-g", "NSStatusItemSelectionPadding"],
            description: "Removing NSStatusItemSelectionPadding setting"
        )
        
        if spacingSuccess && paddingSuccess {
            logger.info("Successfully reset defaults settings, attempting to restart ControlCenter")
            
            let killSuccess = runCommand(
                path: "/usr/bin/killall", 
                arguments: ["ControlCenter"],
                description: "Restarting ControlCenter to apply reset"
            )
            
            if killSuccess {
                showFeedback("Reset to Default!")
                logger.info("Settings reset successfully and ControlCenter restarted")
            } else {
                showFeedback("Settings reset, but ControlCenter restart failed. You may need to restart manually or log out/in.")
                logger.warning("Settings reset but ControlCenter restart failed - user may need manual restart")
            }
        } else {
            showFeedback("Failed to reset some settings. Check Console.app for details.")
            logger.error("Failed to reset one or more settings")
        }
    }
    
    /// A helper function to execute shell commands with comprehensive logging and error handling.
    private func runCommand(path: String, arguments: [String], description: String) -> Bool {
        logger.info("Executing command: \(description)")
        logger.debug("Command details - path: \(path), arguments: \(arguments)")
        
        let task = Process()
        task.launchPath = path
        task.arguments = arguments
        
        // Set up pipes to capture output and errors
        let outputPipe = Pipe()
        let errorPipe = Pipe()
        task.standardOutput = outputPipe
        task.standardError = errorPipe
        
        do {
            let startTime = Date()
            try task.run()
            logger.debug("Command launched successfully, waiting for completion...")
            
            task.waitUntilExit()
            let executionTime = Date().timeIntervalSince(startTime)
            
            // Read output and error data
            let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
            let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
            
            let outputString = String(data: outputData, encoding: .utf8) ?? ""
            let errorString = String(data: errorData, encoding: .utf8) ?? ""
            
            let exitCode = task.terminationStatus
            
            logger.info("Command completed - exit code: \(exitCode), execution time: \(String(format: "%.3f", executionTime))s")
            
            if !outputString.isEmpty {
                logger.debug("Command output: \(outputString)")
            }
            
            if !errorString.isEmpty {
                if exitCode == 0 {
                    logger.debug("Command stderr (non-error): \(errorString)")
                } else {
                    logger.error("Command error output: \(errorString)")
                }
            }
            
            if exitCode == 0 {
                logger.info("Command succeeded: \(description)")
                return true
            } else {
                logger.error("Command failed with exit code \(exitCode): \(description)")
                
                // Always log error output if available
                if !errorString.isEmpty {
                    logger.error("Command error details: \(errorString)")
                }
                
                // Provide specific guidance for common permission issues
                if path.contains("killall") && exitCode == 1 {
                    logger.error("ControlCenter kill failed - this is common and usually means:")
                    logger.error("1. ControlCenter is protected by System Integrity Protection")
                    logger.error("2. The app doesn't have the necessary permissions")
                    logger.error("3. The user may need to manually restart ControlCenter or log out/in")
                } else if path.contains("defaults") && exitCode == 1 {
                    logger.error("Defaults command failed - possible causes:")
                    logger.error("1. Invalid domain or key name")
                    logger.error("2. Permission denied for writing to defaults")
                    logger.error("3. Invalid value type or format")
                    logger.error("4. System Integrity Protection restrictions")
                }
                
                return false
            }
            
        } catch {
            logger.error("Failed to execute command '\(description)': \(error.localizedDescription)")
            logger.error("Error details: \(String(describing: error))")
            
            // Provide specific guidance for common errors
            if let nsError = error as NSError? {
                logger.error("Error domain: \(nsError.domain), code: \(nsError.code)")
                
                if nsError.domain == NSCocoaErrorDomain && nsError.code == 4 {
                    logger.error("File not found error - check if the command path exists: \(path)")
                }
            }
            
            return false
        }
    }
    
    /// Logs out the current user to apply menu bar changes.
    private func logOutUser() {
        logger.info("Initiating user logout to apply menu bar changes")
        
        let success = runCommand(
            path: "/usr/bin/osascript",
            arguments: ["-e", "tell application \"System Events\" to log out"],
            description: "Logging out user to apply menu bar changes"
        )
        
        if !success {
            logger.error("Failed to initiate logout via AppleScript, trying alternative method")
            
            // Alternative method using launchctl
            let alternativeSuccess = runCommand(
                path: "/bin/launchctl",
                arguments: ["bootout", "gui/\(getuid())"],
                description: "Alternative logout method using launchctl"
            )
            
            if !alternativeSuccess {
                showFeedback("Unable to log out automatically. Please log out manually from the Apple menu.")
                logger.error("Both logout methods failed - user must log out manually")
            }
        }
    }
    
    /// Displays a temporary message to the user.
    private func showFeedback(_ message: String) {
        logger.debug("Showing feedback message: \(message)")
        self.feedbackMessage = message
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.feedbackMessage = ""
            self.logger.debug("Feedback message cleared")
        }
    }
}


#Preview {
    ContentView()
}


=== TighterMenubar/SystemFontManager.swift ===

import Foundation
import AppKit
import Combine
import os.log

// This class provides the system menu bar font size with basic dynamic updates
class SystemFontManager: ObservableObject {
    @Published var menuBarFontSize: CGFloat
    
    private var timer: Timer?
    private let logger = Logger(subsystem: "com.tightermenubar.app", category: "SystemFontManager")

    init() {
        // Set the initial font size using the system default
        self.menuBarFontSize = NSFont.menuBarFont(ofSize: 0).pointSize
        logger.info("SystemFontManager initialized with font size: \(self.menuBarFontSize, privacy: .public)")
        
        // Set up a timer to periodically check for font size changes
        // This is a simpler approach than KVO on UserDefaults
        logger.debug("Setting up font size monitoring timer with 1.0 second interval")
        self.timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateFontSize()
        }
        logger.info("Font size monitoring timer started successfully")
    }
    
    deinit {
        logger.info("SystemFontManager deinitializing - invalidating timer")
        timer?.invalidate()
    }

    private func updateFontSize() {
        let currentSize = NSFont.menuBarFont(ofSize: 0).pointSize
        
        if currentSize != menuBarFontSize {
            logger.info("Font size changed from \(self.menuBarFontSize, privacy: .public) to \(currentSize, privacy: .public)")
            DispatchQueue.main.async {
                self.menuBarFontSize = currentSize
                self.logger.debug("Font size updated on main queue")
            }
        }
        // Removed the constant "no change detected" logging to reduce noise
    }
}

=== TighterMenubar/TighterMenubarApp.swift ===

import SwiftUI
import os.log

@main
struct TighterMenubarApp: App {
    private let logger = Logger(subsystem: "com.tightermenubar.app", category: "TighterMenubarApp")
    
    init() {
        logger.info("TighterMenubar app initializing")
        logger.debug("App bundle identifier: \(Bundle.main.bundleIdentifier ?? "unknown")")
        logger.debug("App version: \(Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "unknown")")
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .onAppear {
                    logger.info("Main ContentView appeared")
                }
                .onOpenURL { url in
                    logger.info("App opened with URL: \(url.absoluteString)")
                }
        }
        .windowResizability(.contentSize)
        .defaultSize(width: 320, height: 320)
    }
}


